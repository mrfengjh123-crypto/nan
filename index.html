<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>2026 快乐</title>
    <style>
        /* 防止页面滚动和白边 */
        body, html { 
            margin: 0; 
            padding: 0; 
            width: 100%; 
            height: 100%; 
            overflow: hidden; 
            background-color: #000; 
            font-family: "Microsoft YaHei", sans-serif;
            /* 阻止 iOS 上的橡皮筋滚动效果 */
            position: fixed; 
        }
        canvas { display: block; }
        
        /* 文字容器样式 */
        #text-container {
            position: absolute;
            left: 10%;
            top: 40%;
            color: white;
            z-index: 10;
            pointer-events: none; /* 确保点击事件能穿透文字传给body触发音乐 */
            /* 增加粉色文字辉光 */
            text-shadow: 0 0 15px rgba(255,105,180, 0.9);
        }
        .line1 { font-size: 28px; font-weight: bold; margin-bottom: 12px; }
        .line2 { font-size: 18px; opacity: 0.95; letter-spacing: 1px; }

        /* 音乐提示（可选，不想显示可以删掉下面这行） */
        #music-hint { position: absolute; bottom: 20px; width: 100%; text-align: center; color: rgba(255,255,255,0.5); font-size: 12px; pointer-events: none; }
    </style>
</head>
<body>

    <div id="text-container">
        <div class="line1">2026快乐！</div>
        <div class="line2">希望我的楠楠天天快乐！</div>
    </div>
    <div id="music-hint">轻触屏幕播放音乐</div>

    <audio id="bgm" loop preload="auto">
        <source src="music.mp3" type="audio/mpeg">
        您的浏览器不支持音频元素。
    </audio>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        let scene, camera, renderer, particles, particleSystem;
        const particleCount = 12000; // 粒子数量，数量越多越密集但可能影响性能

        // --- 核心功能：创建发光粒子纹理 ---
        // 通过代码生成一张圆形的、边缘渐变透明的图片，用于模拟发光效果
        function createLightTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            // 创建径向渐变 (中心白 -> 边缘透明)
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');   // 中心极亮
            gradient.addColorStop(0.2, 'rgba(255,230,240,0.8)'); // 稍微带点粉
            gradient.addColorStop(0.5, 'rgba(255,100,180,0.2)'); // 边缘粉色光晕
            gradient.addColorStop(1, 'rgba(0,0,0,0)');         // 最外圈透明

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        function init() {
            // 1. 场景初始化
            scene = new THREE.Scene();
            // 添加一点环境雾效，增加深邃感
            scene.fog = new THREE.FogExp2(0x000000, 0.05);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5.5; // 摄像机距离
            camera.position.y = 1.8; // 摄像机高度

            renderer = new THREE.WebGLRenderer({ 
                antialias: true, // 抗锯齿
                alpha: true,     // 允许透明背景
                powerPreference: "high-performance" // 优先使用高性能GPU
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // 限制最大像素比，平衡性能
            document.body.appendChild(renderer.domElement);

            // 2. 创建粒子几何体数据
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount); // 每个粒子的大小差异

            const colorBase = new THREE.Color("#ff69b4"); // 基础亮粉色
            const colorDark = new THREE.Color("#c71585"); // 深粉色

            for (let i = 0; i < particleCount; i++) {
                // 螺旋树算法核心
                const t = i / particleCount;
                // 增加圈数，让树更高更密
                const angle = t * Math.PI * 24; 
                // 半径随高度变化
                const radius = (1.2 - t) * 2.0; 
                
                // 增加随机抖动，模拟烟雾感
                const randomOffset = (Math.random() - 0.5) * 0.15 * (1-t); 

                positions[i * 3] = Math.cos(angle) * radius + randomOffset;
                positions[i * 3 + 1] = (t * 5) - 2.5; // 高度拉伸
                positions[i * 3 + 2] = Math.sin(angle) * radius + randomOffset;

                // 颜色渐变：底部深粉 -> 顶部亮白粉
                const mixedColor = colorDark.clone().lerp(colorBase, t * 1.5);
                // 顶部加一点白色提亮
                if (t > 0.95) mixedColor.lerp(new THREE.Color(1,1,1), (t-0.95)*10);

                colors[i * 3] = mixedColor.r;
                colors[i * 3 + 1] = mixedColor.g;
                colors[i * 3 + 2] = mixedColor.b;

                // 粒子大小随机化，顶部粒子稍小
                sizes[i] = (Math.random() * 0.1 + 0.05) * (1.2 - t * 0.5);
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            // 3. 创建发光材质 (关键点!)
            const material = new THREE.PointsMaterial({
                size: 0.1, // 基础大小，会被上面的 attribute 覆盖
                vertexColors: true,
                map: createLightTexture(), // 使用我们生成的发光贴图
                transparent: true,
                opacity: 0.9,
                // 核心：加法混合，重叠变亮，创造发光感
                blending: THREE.AdditiveBlending,
                depthWrite: false, // 防止透明粒子互相遮挡产生黑边
                sizeAttenuation: true // 粒子近大远小
            });

            // 修改材质着色器以支持单个粒子大小差异 (高级操作)
            material.onBeforeCompile = (shader) => {
                shader.vertexShader = 'attribute float size;\n' + shader.vertexShader;
                shader.vertexShader = shader.vertexShader.replace(
                    'gl_PointSize = size;',
                    'gl_PointSize = size * ( 300.0 / -mvPosition.z );' // 根据距离调整大小
                );
            };

            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);

            // 监听窗口大小变化
            window.addEventListener('resize', onWindowResize, false);
            
            // 处理音乐播放
            setupAudio();

            animate();
        }

        // --- 音乐播放处理 (适配微信) ---
        function setupAudio() {
            const audio = document.getElementById('bgm');
            let musicPlayed = false;

            function playMusic() {
                if (musicPlayed) return;
                audio.play().then(() => {
                    console.log("Music started successfully");
                    // 隐藏提示文字
                    const hint = document.getElementById('music-hint');
                    if(hint) hint.style.display = 'none';
                    musicPlayed = true;
                }).catch(err => {
                    console.log("Autoplay prevented, waiting for interaction.");
                });
            }

            // 尝试自动播放 (某些浏览器允许)
            playMusic();

            // 微信/iOS 需要用户首次交互才能播放声音
            // 监听任意触摸或点击事件
            document.body.addEventListener('touchstart', playMusic, { once: true });
            document.body.addEventListener('click', playMusic, { once: true });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            // requestAnimationFrame 会自动匹配设备最高刷新率 (如 120Hz)
            requestAnimationFrame(animate); 
            
            // 让整个粒子系统缓慢旋转
            particleSystem.rotation.y += 0.003; 
            
            // 可选：让粒子轻微上下浮动，增加动态感
            const time = Date.now() * 0.001;
            particleSystem.position.y = Math.sin(time * 0.5) * 0.05;

            renderer.render(scene, camera);
        }

        // 启动!
        init();
    </script>
</body>
</html>